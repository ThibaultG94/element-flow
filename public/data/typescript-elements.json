{
  "awaited-type": {
    "name": "Awaited<Type>",
    "category": "utility-types",
    "description": "Un type utilitaire qui modélise le comportement des opérations await en TypeScript, permettant d'extraire le type que retournerait une Promise une fois résolue.",
    "syntax": "Awaited<Type>",
    "attributes": [
      {
        "name": "Type",
        "description": "Le type à 'désemballer', généralement un type Promise ou un type similaire imbriqué."
      },
      {
        "name": "Désemballage récursif",
        "description": "Awaited<Type> va récursivement désemballer les Promises imbriquées jusqu'à atteindre un type non-Promise."
      },
      {
        "name": "Union types",
        "description": "Fonctionne également avec les unions de types, désemballant chaque membre de l'union."
      }
    ],
    "examples": [
      {
        "title": "Extraction du type d'une Promise simple",
        "code": "// Désemballer une Promise simple\ntype A = Awaited<Promise<string>>;\n// type A = string\n\n// Désemballer des Promises imbriquées\ntype B = Awaited<Promise<Promise<number>>>;\n// type B = number\n\n// Fonctionne avec les unions de types\ntype C = Awaited<boolean | Promise<number>>;\n// type C = number | boolean"
      },
      {
        "title": "Utilisation pratique avec des fonctions async",
        "code": "async function fetchUserData(): Promise<{ id: number; name: string }> {\n  // Simulation d'un appel API\n  return { id: 1, name: 'Alice' };\n}\n\n// Extraire le type de retour effectif\ntype UserData = Awaited<ReturnType<typeof fetchUserData>>;\n// équivalent à: type UserData = { id: number; name: string };\n\n// Utile pour les fonctions qui manipulent le résultat\nfunction processUser(user: UserData) {\n  console.log(`Traitement de l'utilisateur ${user.name}`);\n}"
      }
    ],
    "animation": {
      "steps": [
        {
          "title": "Introduction à Awaited<Type>",
          "text": "Awaited<Type> est un type utilitaire qui simule le comportement de l'opérateur await sur les Promises en TypeScript, en extrayant le type que contiendrait une Promise une fois résolue.",
          "code": "// Comprendre la différence entre ces types:\n\ntype PromiseType = Promise<string>;\n// Le type est la Promise elle-même\n\ntype ResolvedType = Awaited<Promise<string>>;\n// Le type est string - ce que la Promise résout",
          "visualDemo": {
            "content": "<div style='font-family: monospace; background-color: #1e1e1e; color: #d4d4d4; padding: 16px; border-radius: 6px; max-width: 100%; overflow: hidden;'><div style='margin-bottom: 12px; color: #9cdcfe; font-size: 15px; border-bottom: 1px solid #3e3e3e; padding-bottom: 8px;'>Sans vs Avec Awaited</div><div style='display: flex; flex-direction: column; gap: 12px;'><div style='background-color: #252526; padding: 10px; border-radius: 4px;'><span style='color: #569cd6;'>type</span> <span style='color: #4ec9b0;'>T</span> = <span style='color: #4ec9b0;'>Promise</span>&lt;<span style='color: #ce9178;'>string</span>&gt;;<div style='margin-top: 6px; color: #6a9955;'>// Résultat: Promise&lt;string&gt;</div></div><div style='background-color: #252526; padding: 10px; border-radius: 4px;'><span style='color: #569cd6;'>type</span> <span style='color: #4ec9b0;'>T</span> = <span style='color: #569cd6;'>Awaited</span>&lt;<span style='color: #4ec9b0;'>Promise</span>&lt;<span style='color: #ce9178;'>string</span>&gt;&gt;;<div style='margin-top: 6px; color: #6a9955;'>// Résultat: string</div></div></div></div>"
          }
        },
        {
          "title": "Désemballage récursif des Promises",
          "text": "Awaited<Type> peut récursivement désemballer des Promises imbriquées à n'importe quelle profondeur, jusqu'à ce qu'il atteigne un type non-Promise.",
          "code": "// Promises imbriquées\ntype A = Promise<string>;\ntype B = Promise<Promise<string>>;\ntype C = Promise<Promise<Promise<string>>>;\n\n// Awaited désemballe récursivement\ntype ResolvedA = Awaited<A>;  // string\ntype ResolvedB = Awaited<B>;  // string\ntype ResolvedC = Awaited<C>;  // string",
          "visualDemo": {
            "content": "<div style='font-family: monospace; background-color: #1e1e1e; color: #d4d4d4; padding: 16px; border-radius: 6px; max-width: 100%; overflow: hidden;'><div style='margin-bottom: 16px; color: #9cdcfe; font-size: 15px; border-bottom: 1px solid #3e3e3e; padding-bottom: 8px;'>Désemballage récursif</div><div style='display: flex; flex-direction: column; gap: 16px;'><div style='display: flex; align-items: center;'><div style='min-width: 220px; font-size: 14px; color: #9cdcfe; overflow: hidden; text-overflow: ellipsis;'><span style='color: #4ec9b0;'>Promise</span>&lt;<span style='color: #ce9178;'>string</span>&gt;</div><div style='margin: 0 8px;'><svg width='20' height='20' viewBox='0 0 24 24' fill='none'><path d='M5 12h14M12 5l7 7-7 7' stroke='#569cd6' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'/></svg></div><div style='font-size: 14px; padding: 5px 10px; background-color: #264f78; border-radius: 4px; color: #9cdcfe;'><span style='color: #ce9178;'>string</span></div></div><div style='display: flex; align-items: center;'><div style='min-width: 220px; font-size: 14px; color: #9cdcfe; overflow: hidden; text-overflow: ellipsis;'><span style='color: #4ec9b0;'>Promise</span>&lt;<span style='color: #4ec9b0;'>Promise</span>&lt;<span style='color: #ce9178;'>string</span>&gt;&gt;</div><div style='margin: 0 8px;'><svg width='20' height='20' viewBox='0 0 24 24' fill='none'><path d='M5 12h14M12 5l7 7-7 7' stroke='#569cd6' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'/></svg></div><div style='font-size: 14px; padding: 5px 10px; background-color: #264f78; border-radius: 4px; color: #9cdcfe;'><span style='color: #ce9178;'>string</span></div></div><div style='display: flex; align-items: center;'><div style='min-width: 220px; font-size: 14px; color: #9cdcfe; overflow: hidden; text-overflow: ellipsis;'><span style='color: #4ec9b0;'>Promise</span>&lt;<span style='color: #4ec9b0;'>Promise</span>&lt;<span style='color: #4ec9b0;'>Promise</span>&lt;<span style='color: #ce9178;'>string</span>&gt;&gt;&gt;</div><div style='margin: 0 8px;'><svg width='20' height='20' viewBox='0 0 24 24' fill='none'><path d='M5 12h14M12 5l7 7-7 7' stroke='#569cd6' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'/></svg></div><div style='font-size: 14px; padding: 5px 10px; background-color: #264f78; border-radius: 4px; color: #9cdcfe;'><span style='color: #ce9178;'>string</span></div></div></div></div>"
          }
        },
        {
          "title": "Gestion des unions de types",
          "text": "Awaited<Type> peut également traiter les unions de types, désemballant chaque membre de l'union indépendamment.",
          "code": "// Unions de types avec Awaited\ntype MixedType = boolean | Promise<number>;\ntype Resolved = Awaited<MixedType>;\n// type Resolved = boolean | number\n\n// Exemple plus complexe avec imbrication\ntype ComplexUnion = Promise<string> | Promise<Promise<number>> | boolean;\ntype ResolvedComplex = Awaited<ComplexUnion>;\n// type ResolvedComplex = string | number | boolean",
          "visualDemo": {
            "content": "<div style='font-family: monospace; background-color: #1e1e1e; color: #d4d4d4; padding: 16px; border-radius: 6px; max-width: 100%; overflow: hidden;'><div style='margin-bottom: 16px; color: #9cdcfe; font-size: 15px; border-bottom: 1px solid #3e3e3e; padding-bottom: 8px;'>Gestion des unions de types</div><div style='margin-bottom: 16px;'><div style='color: #9cdcfe; margin-bottom: 8px;'>Union simple</div><div style='background-color: #252526; padding: 10px; border-radius: 4px; margin-bottom: 8px;'><span style='color: #569cd6;'>type</span> <span style='color: #4ec9b0;'>MixedType</span> = <span style='color: #569cd6;'>boolean</span> | <span style='color: #4ec9b0;'>Promise</span>&lt;<span style='color: #569cd6;'>number</span>&gt;;</div><div style='background-color: #252526; padding: 10px; border-radius: 4px;'><span style='color: #569cd6;'>type</span> <span style='color: #4ec9b0;'>Resolved</span> = <span style='color: #569cd6;'>Awaited</span>&lt;<span style='color: #4ec9b0;'>MixedType</span>&gt;; <span style='color: #6a9955;'>// boolean | number</span></div></div><div><div style='color: #9cdcfe; margin-bottom: 8px;'>Union complexe</div><div style='background-color: #252526; padding: 10px; border-radius: 4px; margin-bottom: 8px;'><span style='color: #569cd6;'>type</span> <span style='color: #4ec9b0;'>ComplexUnion</span> = <span style='color: #4ec9b0;'>Promise</span>&lt;<span style='color: #ce9178;'>string</span>&gt; | <span style='color: #4ec9b0;'>Promise</span>&lt;<span style='color: #4ec9b0;'>Promise</span>&lt;<span style='color: #569cd6;'>number</span>&gt;&gt; | <span style='color: #569cd6;'>boolean</span>;</div><div style='background-color: #252526; padding: 10px; border-radius: 4px;'><span style='color: #569cd6;'>type</span> <span style='color: #4ec9b0;'>ResolvedComplex</span> = <span style='color: #569cd6;'>Awaited</span>&lt;<span style='color: #4ec9b0;'>ComplexUnion</span>&gt;; <span style='color: #6a9955;'>// string | number | boolean</span></div></div></div>"
          }
        },
        {
          "title": "Cas d'utilisation pratique avec ReturnType",
          "text": "Une utilisation courante d'Awaited<Type> est de l'associer avec ReturnType pour extraire le type de retour effectif d'une fonction asynchrone.",
          "code": "// Définition d'une fonction async\nasync function fetchData() {\n  const response = await fetch('https://api.example.com/data');\n  return await response.json() as { results: string[] };\n}\n\n// Sans Awaited\ntype Result1 = ReturnType<typeof fetchData>;\n// type Result1 = Promise<{ results: string[] }>\n\n// Avec Awaited\ntype Result2 = Awaited<ReturnType<typeof fetchData>>;\n// type Result2 = { results: string[] }",
          "visualDemo": {
            "content": "<div style='font-family: monospace; background-color: #1e1e1e; color: #d4d4d4; padding: 16px; border-radius: 6px; max-width: 100%; overflow: hidden;'><div style='margin-bottom: 16px; color: #9cdcfe; font-size: 15px; border-bottom: 1px solid #3e3e3e; padding-bottom: 8px;'>Utilisation avec ReturnType</div><div style='background-color: #252526; padding: 10px; border-radius: 4px; margin-bottom: 16px;'><span style='color: #569cd6;'>async</span> <span style='color: #dcdcaa;'>function</span> <span style='color: #dcdcaa;'>fetchData</span>() { <span style='color: #6a9955;'>/* ... */</span> }</div><div style='display: flex; flex-direction: column; gap: 16px;'><div style='background-color: #252526; padding: 10px; border-radius: 4px;'><span style='color: #569cd6;'>type</span> <span style='color: #4ec9b0;'>Result1</span> = <span style='color: #4ec9b0;'>ReturnType</span>&lt;<span style='color: #569cd6;'>typeof</span> <span style='color: #dcdcaa;'>fetchData</span>&gt;;<div style='margin-top: 6px; color: #6a9955;'>// type Result1 = Promise&lt;{ results: string[] }&gt;</div></div><div style='background-color: #252526; padding: 10px; border-radius: 4px;'><span style='color: #569cd6;'>type</span> <span style='color: #4ec9b0;'>Result2</span> = <span style='color: #569cd6;'>Awaited</span>&lt;<span style='color: #4ec9b0;'>ReturnType</span>&lt;<span style='color: #569cd6;'>typeof</span> <span style='color: #dcdcaa;'>fetchData</span>&gt;&gt;;<div style='margin-top: 6px; color: #6a9955;'>// type Result2 = { results: string[] }</div></div></div></div>"
          }
        },
        {
          "title": "Implémentation dans TypeScript",
          "text": "Comprendre comment Awaited<Type> est implémenté dans TypeScript peut aider à mieux comprendre son fonctionnement.",
          "code": "// Voici une version simplifiée de l'implémentation dans TypeScript:\n\ntype Awaited<T> =\n  T extends null | undefined ? T :\n  T extends object & { then(onfulfilled: infer F): any } ?\n    F extends ((value: infer V, ...args: any) => any) ?\n      Awaited<V> :\n      never :\n  T;",
          "visualDemo": {
            "content": "<div style='font-family: monospace; background-color: #1e1e1e; color: #d4d4d4; padding: 16px; border-radius: 6px; max-width: 100%; overflow: hidden;'><div style='margin-bottom: 16px; color: #9cdcfe; font-size: 15px; border-bottom: 1px solid #3e3e3e; padding-bottom: 8px;'>Comment fonctionne Awaited&lt;Type&gt;</div><div style='background-color: #252526; padding: 12px; border-radius: 4px; margin-bottom: 16px;'><div style='margin-bottom: 8px; color: #9cdcfe;'>Étapes de vérification</div><ol style='margin: 0; padding-left: 20px;'><li style='margin-bottom: 6px;'><span style='color: #4ec9b0;'>T extends null | undefined</span> → Retourne T tel quel</li><li style='margin-bottom: 6px;'><span style='color: #4ec9b0;'>T extends { then() }</span> → Vérifie si T est une Promise/thenable</li><li style='margin-bottom: 6px;'><span style='color: #569cd6;'>infer F, infer V</span> → Extrait le type du callback et sa valeur</li><li><span style='color: #569cd6;'>Awaited&lt;V&gt;</span> → Appel récursif pour gérer l'imbrication</li></ol></div><div style='display: flex; justify-content: center;'><div style='background-color: #252526; padding: 12px; border-radius: 4px; max-width: 320px;'><div style='color: #9cdcfe; margin-bottom: 8px; text-align: center;'>Exemple d'application</div><code><div style='color: #569cd6;'>type</span> <span style='color: #4ec9b0;'>P</span> = <span style='color: #4ec9b0;'>Promise</span>&lt;<span style='color: #4ec9b0;'>Promise</span>&lt;<span style='color: #569cd6;'>number</span>&gt;&gt;;</div><div style='color: #569cd6;'>type</span> <span style='color: #4ec9b0;'>R</span> = <span style='color: #569cd6;'>Awaited</span>&lt;<span style='color: #4ec9b0;'>P</span>&gt;; <span style='color: #6a9955;'>// number</span></code></div></div></div>"
          }
        }
      ]
    },
    "exercises": [
      {
        "type": "qcm",
        "question": "Quel sera le résultat de type Awaited<Promise<Promise<number>>> ?",
        "options": [
          "Promise<Promise<number>>",
          "Promise<number>",
          "number",
          "unknown"
        ],
        "correctAnswer": 2,
        "explanation": "Awaited<Type> désemballe récursivement les Promises imbriquées, peu importe le niveau d'imbrication. Pour Awaited<Promise<Promise<number>>>, le résultat sera donc 'number'."
      },
      {
        "type": "vrai_faux",
        "question": "Awaited<string | Promise<number>> donnera comme résultat string | number.",
        "correctAnswer": true,
        "explanation": "Oui, c'est vrai. Awaited<Type> fonctionne sur les unions de types et applique le désemballage à chaque membre de l'union séparément. Pour 'string', il reste 'string' (car ce n'est pas une Promise), et pour Promise<number>, il devient 'number'."
      },
      {
        "type": "completion",
        "question": "Complétez le code pour obtenir directement le type de données retourné par la fonction fetchData sans l'enveloppe Promise :",
        "codeTemplate": "async function fetchData() {\n  const response = await fetch('/api/users');\n  return await response.json() as User[];\n}\n\ntype Result = [?]<ReturnType<typeof fetchData>>;",
        "correctAnswer": "Awaited",
        "explanation": "La fonction fetchData retourne Promise<User[]>. En utilisant ReturnType<typeof fetchData>, on obtient ce type Promise<User[]>. Pour extraire User[] de cette Promise, on utilise Awaited<>."
      },
      {
        "type": "debugging",
        "question": "Trouvez et corrigez l'erreur dans ce code TypeScript :",
        "buggyCode": "async function getData(): Promise<string> {\n  return 'data';\n}\n\n// Tentative d'utiliser le type retourné\ntype DataType = ReturnType<typeof getData>;\nconst processData = (data: DataType) => {\n  console.log(data.toUpperCase());\n};",
        "correctAnswer": "async function getData(): Promise<string> {\n  return 'data';\n}\n\n// Utilisez Awaited pour extraire le type de la Promise\ntype DataType = Awaited<ReturnType<typeof getData>>;\nconst processData = (data: DataType) => {\n  console.log(data.toUpperCase());\n};",
        "explanation": "L'erreur est que ReturnType<typeof getData> donne Promise<string>, mais processData essaie d'utiliser .toUpperCase() directement sur ce type. Or, .toUpperCase() est une méthode de string, pas de Promise<string>. En utilisant Awaited<ReturnType<typeof getData>>, on obtient le type string, ce qui permet d'appeler .toUpperCase()."
      }
    ],
    "related": ["Promise", "ReturnType", "Partial", "Required", "async-await", "generics"]
  }
}