{
  "awaited-type": {
    "name": "Awaited<Type>",
    "category": "utility-types",
    "description": "Un type utilitaire qui modélise le comportement des opérations await en TypeScript, permettant d'extraire le type que retournerait une Promise une fois résolue.",
    "syntax": "Awaited<Type>",
    "attributes": [
      {
        "name": "Type",
        "description": "Le type à 'désemballer', généralement un type Promise ou un type similaire imbriqué."
      },
      {
        "name": "Désemballage récursif",
        "description": "Awaited<Type> va récursivement désemballer les Promises imbriquées jusqu'à atteindre un type non-Promise."
      },
      {
        "name": "Union types",
        "description": "Fonctionne également avec les unions de types, désemballant chaque membre de l'union."
      }
    ],
    "examples": [
      {
        "title": "Extraction du type d'une Promise simple",
        "code": "// Désemballer une Promise simple\ntype A = Awaited<Promise<string>>;\n// type A = string\n\n// Désemballer des Promises imbriquées\ntype B = Awaited<Promise<Promise<number>>>;\n// type B = number\n\n// Fonctionne avec les unions de types\ntype C = Awaited<boolean | Promise<number>>;\n// type C = number | boolean"
      },
      {
        "title": "Utilisation pratique avec des fonctions async",
        "code": "async function fetchUserData(): Promise<{ id: number; name: string }> {\n  // Simulation d'un appel API\n  return { id: 1, name: 'Alice' };\n}\n\n// Extraire le type de retour effectif\ntype UserData = Awaited<ReturnType<typeof fetchUserData>>;\n// équivalent à: type UserData = { id: number; name: string };\n\n// Utile pour les fonctions qui manipulent le résultat\nfunction processUser(user: UserData) {\n  console.log(`Traitement de l'utilisateur ${user.name}`);\n}"
      }
    ],
    "animation": {
      "steps": [
        {
          "title": "Introduction à Awaited<Type>",
          "text": "Awaited<Type> est un type utilitaire qui simule le comportement de l'opérateur await sur les Promises en TypeScript, en extrayant le type que contiendrait une Promise une fois résolue.",
          "code": "// Comprendre la différence entre ces types:\n\ntype PromiseType = Promise<string>;\n// Le type est la Promise elle-même\n\ntype ResolvedType = Awaited<Promise<string>>;\n// Le type est string - ce que la Promise résout",
          "visualDemo": {
            "content": "<div style='font-family: monospace; background-color: #f5f5f5; padding: 16px; border-radius: 8px;'><div style='display: flex; margin-bottom: 15px;'><div style='width: 50%;'><strong>Sans Awaited:</strong><br><code>type T = Promise&lt;string&gt;</code></div><div style='width: 50%; background-color: #e9ecef; padding: 8px; border-radius: 4px;'><code>Promise&lt;string&gt;</code></div></div><div style='display: flex;'><div style='width: 50%;'><strong>Avec Awaited:</strong><br><code>type T = Awaited&lt;Promise&lt;string&gt;&gt;</code></div><div style='width: 50%; background-color: #e9ecef; padding: 8px; border-radius: 4px;'><code>string</code></div></div></div>"
          }
        },
        {
          "title": "Désemballage récursif des Promises",
          "text": "Awaited<Type> peut récursivement désemballer des Promises imbriquées à n'importe quelle profondeur, jusqu'à ce qu'il atteigne un type non-Promise.",
          "code": "// Promises imbriquées\ntype A = Promise<string>;\ntype B = Promise<Promise<string>>;\ntype C = Promise<Promise<Promise<string>>>;\n\n// Awaited désemballe récursivement\ntype ResolvedA = Awaited<A>;  // string\ntype ResolvedB = Awaited<B>;  // string\ntype ResolvedC = Awaited<C>;  // string",
          "visualDemo": {
            "content": "<div style='padding: 16px; background-color: #f8f9fa; border-radius: 8px;'><div style='display: flex; flex-direction: column; gap: 15px;'><div style='display: flex; align-items: center;'><div style='width: 300px;'><code>Awaited&lt;Promise&lt;string&gt;&gt;</code></div><div style='display: flex; align-items: center;'><div style='width: 30px; text-align: center;'>→</div><div style='background-color: #e9ecef; padding: 5px 10px; border-radius: 4px;'><code>string</code></div></div></div><div style='display: flex; align-items: center;'><div style='width: 300px;'><code>Awaited&lt;Promise&lt;Promise&lt;string&gt;&gt;&gt;</code></div><div style='display: flex; align-items: center;'><div style='width: 30px; text-align: center;'>→</div><div style='background-color: #e9ecef; padding: 5px 10px; border-radius: 4px;'><code>string</code></div></div></div><div style='display: flex; align-items: center;'><div style='width: 300px;'><code>Awaited&lt;Promise&lt;Promise&lt;Promise&lt;string&gt;&gt;&gt;&gt;</code></div><div style='display: flex; align-items: center;'><div style='width: 30px; text-align: center;'>→</div><div style='background-color: #e9ecef; padding: 5px 10px; border-radius: 4px;'><code>string</code></div></div></div></div></div>"
          }
        },
        {
          "title": "Gestion des unions de types",
          "text": "Awaited<Type> peut également traiter les unions de types, désemballant chaque membre de l'union indépendamment.",
          "code": "// Unions de types avec Awaited\ntype MixedType = boolean | Promise<number>;\ntype Resolved = Awaited<MixedType>;\n// type Resolved = boolean | number\n\n// Exemple plus complexe avec imbrication\ntype ComplexUnion = Promise<string> | Promise<Promise<number>> | boolean;\ntype ResolvedComplex = Awaited<ComplexUnion>;\n// type ResolvedComplex = string | number | boolean",
          "visualDemo": {
            "content": "<div style='padding: 16px; background-color: #f8f9fa; border-radius: 8px;'><div style='margin-bottom: 20px;'><div style='font-weight: bold; margin-bottom: 10px;'>Union simple:</div><div style='display: flex; align-items: center;'><div style='padding: 8px; background-color: #e2e3e5; border-radius: 4px; margin-right: 15px;'><code>boolean | Promise&lt;number&gt;</code></div><div style='font-size: 20px; margin-right: 15px;'>⟹</div><div style='padding: 8px; background-color: #d1e7dd; border-radius: 4px;'><code>Awaited&lt;boolean | Promise&lt;number&gt;&gt;</code></div><div style='font-size: 20px; margin: 0 15px;'>⟹</div><div style='padding: 8px; background-color: #cff4fc; border-radius: 4px;'><code>boolean | number</code></div></div></div><div><div style='font-weight: bold; margin-bottom: 10px;'>Union complexe:</div><div style='display: flex; flex-wrap: wrap; gap: 10px; margin-bottom: 15px;'><div style='padding: 5px; background-color: #e2e3e5; border-radius: 4px;'><code>Promise&lt;string&gt;</code></div><div style='padding: 5px; background-color: #e2e3e5; border-radius: 4px;'><code>Promise&lt;Promise&lt;number&gt;&gt;</code></div><div style='padding: 5px; background-color: #e2e3e5; border-radius: 4px;'><code>boolean</code></div></div><div style='text-align: center; margin-bottom: 15px;'>⟇ <code>Awaited&lt;...&gt;</code></div><div style='display: flex; flex-wrap: wrap; gap: 10px;'><div style='padding: 5px; background-color: #d1e7dd; border-radius: 4px;'><code>string</code></div><div style='padding: 5px; background-color: #d1e7dd; border-radius: 4px;'><code>number</code></div><div style='padding: 5px; background-color: #d1e7dd; border-radius: 4px;'><code>boolean</code></div></div></div></div>"
          }
        },
        {
          "title": "Cas d'utilisation pratique avec ReturnType",
          "text": "Une utilisation courante d'Awaited<Type> est de l'associer avec ReturnType pour extraire le type de retour effectif d'une fonction asynchrone.",
          "code": "// Définition d'une fonction async\nasync function fetchData() {\n  const response = await fetch('https://api.example.com/data');\n  return await response.json() as { results: string[] };\n}\n\n// Sans Awaited\ntype Result1 = ReturnType<typeof fetchData>;\n// type Result1 = Promise<{ results: string[] }>\n\n// Avec Awaited\ntype Result2 = Awaited<ReturnType<typeof fetchData>>;\n// type Result2 = { results: string[] }",
          "visualDemo": {
            "content": "<div style='padding: 16px; background-color: #f8f9fa; border-radius: 8px;'><div style='background-color: #e2e3e5; padding: 10px; border-radius: 4px; margin-bottom: 15px;'><code>async function fetchData() { ... }</code></div><div style='display: flex; flex-direction: column; gap: 15px;'><div style='display: flex; align-items: center;'><div style='width: 220px;'><code>ReturnType&lt;typeof fetchData&gt;</code></div><div style='width: 30px; text-align: center;'>→</div><div style='background-color: #f8d7da; padding: 5px 10px; border-radius: 4px; flex-grow: 1;'><code>Promise&lt;{ results: string[] }&gt;</code></div></div><div style='display: flex; align-items: center;'><div style='width: 220px;'><code>Awaited&lt;ReturnType&lt;typeof fetchData&gt;&gt;</code></div><div style='width: 30px; text-align: center;'>→</div><div style='background-color: #d1e7dd; padding: 5px 10px; border-radius: 4px; flex-grow: 1;'><code>{ results: string[] }</code></div></div></div></div>"
          }
        },
        {
          "title": "Implémentation dans TypeScript",
          "text": "Comprendre comment Awaited<Type> est implémenté dans TypeScript peut aider à mieux comprendre son fonctionnement.",
          "code": "// Voici une version simplifiée de l'implémentation dans TypeScript:\n\ntype Awaited<T> =\n  T extends null | undefined ? T :\n  T extends object & { then(onfulfilled: infer F): any } ?\n    F extends ((value: infer V, ...args: any) => any) ?\n      Awaited<V> :\n      never :\n  T;",
          "visualDemo": {
            "content": "<div style='padding: 16px; background-color: #f5f5f5; border-radius: 8px;'><div style='margin-bottom: 16px;'><strong>Comment fonctionne Awaited&lt;Type&gt;:</strong></div><ol style='margin-left: 20px;'><li>Vérifie si le type est null/undefined et les retourne tels quels</li><li>Vérifie si le type est un objet avec une méthode .then (thenable)</li><li>Si c'est le cas, extrait le type V du callback onfulfilled</li><li>Appelle récursivement Awaited&lt;V&gt; pour désemballer les promesses imbriquées</li><li>Si ce n'est pas une Promise/thenable, retourne simplement T</li></ol><div style='margin-top: 16px; font-style: italic;'>Cette approche récursive permet de désemballer des Promises imbriquées à n'importe quelle profondeur.</div></div>"
          }
        }
      ]
    },
    "related": ["Promise", "ReturnType", "Partial", "Required", "async-await", "generics"]
  }
}