{
  "awaited-type": {
    "name": "Awaited<Type>",
    "category": "utility-types",
    "description": "Un type utilitaire qui modélise le comportement des opérations await en TypeScript, permettant d'extraire le type que retournerait une Promise une fois résolue.",
    "syntax": "Awaited<Type>",
    "attributes": [
      {
        "name": "Type",
        "description": "Le type à 'désemballer', généralement un type Promise ou un type similaire imbriqué."
      },
      {
        "name": "Désemballage récursif",
        "description": "Awaited<Type> va récursivement désemballer les Promises imbriquées jusqu'à atteindre un type non-Promise."
      },
      {
        "name": "Union types",
        "description": "Fonctionne également avec les unions de types, désemballant chaque membre de l'union."
      }
    ],
    "examples": [
      {
        "title": "Extraction du type d'une Promise simple",
        "code": "// Désemballer une Promise simple\ntype A = Awaited<Promise<string>>;\n// type A = string\n\n// Désemballer des Promises imbriquées\ntype B = Awaited<Promise<Promise<number>>>;\n// type B = number\n\n// Fonctionne avec les unions de types\ntype C = Awaited<boolean | Promise<number>>;\n// type C = number | boolean"
      },
      {
        "title": "Utilisation pratique avec des fonctions async",
        "code": "async function fetchUserData(): Promise<{ id: number; name: string }> {\n  // Simulation d'un appel API\n  return { id: 1, name: 'Alice' };\n}\n\n// Extraire le type de retour effectif\ntype UserData = Awaited<ReturnType<typeof fetchUserData>>;\n// équivalent à: type UserData = { id: number; name: string };\n\n// Utile pour les fonctions qui manipulent le résultat\nfunction processUser(user: UserData) {\n  console.log(`Traitement de l'utilisateur ${user.name}`);\n}"
      }
    ],
    "animation": {
      "steps": [
        {
          "title": "Concept d'Awaited<Type>",
          "text": "Awaited<Type> simule le comportement de l'opérateur await en TypeScript, permettant d'extraire le type réel d'une Promise une fois résolue.",
          "code": "// L'essence d'Awaited\n\ntype StringPromise = Promise<string>;\ntype ResolvedType = Awaited<StringPromise>;\n// type ResolvedType = string\n\ntype NestedPromise = Promise<Promise<number>>;\ntype DeepResolved = Awaited<NestedPromise>;\n// type DeepResolved = number",
          "visualDemo": {
            "content": "<div style='background: linear-gradient(to bottom, #1e1e1e, #252526); border-radius: 8px; padding: 24px; font-family: -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, Oxygen, Ubuntu, Cantarell, sans-serif; color: #d4d4d4; box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);'><div style='text-align: center; margin-bottom: 24px;'><h3 style='font-size: 18px; font-weight: 500; color: #f5f5f5; margin-bottom: 8px;'>Le pouvoir d'Awaited</h3><p style='font-size: 14px; color: #999999; margin: 0;'>Extrait le type réel des Promises</p></div><div style='background: #282a36; border-radius: 6px; padding: 16px; margin-bottom: 16px;'><div style='font-family: \"Fira Code\", Consolas, monospace; font-size: 14px; line-height: 1.6;'><div style='margin-bottom: 8px;'><span style='color: #569cd6;'>Promise&lt;string&gt;</span> <span style='opacity: 0.6;'> → </span> <span style='color: #9cdcfe;'>string</span></div><div><span style='color: #569cd6;'>Promise&lt;Promise&lt;boolean&gt;&gt;</span> <span style='opacity: 0.6;'> → </span> <span style='color: #9cdcfe;'>boolean</span></div></div></div><div style='background: #282a36; border-radius: 6px; padding: 16px; opacity: 0.9;'><div style='text-align: center; color: #999999; font-size: 13px;'>Désemballage jusqu'à atteindre le type réel</div></div></div>"
          }
        },
        {
          "title": "Désemballage récursif & Unions",
          "text": "Awaited<Type> gère élégamment les Promises imbriquées et les unions de types, désemballant chaque niveau jusqu'à atteindre les types primitifs.",
          "code": "// Désemballage récursif\ntype Nested = Promise<Promise<Promise<string>>>;\ntype Result = Awaited<Nested>; // string\n\n// Gestion des unions\ntype MixedTypes = string | Promise<number> | Promise<Promise<boolean>>;\ntype UnifiedResult = Awaited<MixedTypes>;\n// type UnifiedResult = string | number | boolean",
          "visualDemo": {
            "content": "<div style='background: linear-gradient(to bottom, #1e1e1e, #252526); border-radius: 8px; padding: 24px; font-family: -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, Oxygen, Ubuntu, Cantarell, sans-serif; color: #d4d4d4; box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);'><div style='text-align: center; margin-bottom: 24px;'><h3 style='font-size: 18px; font-weight: 500; color: #f5f5f5; margin-bottom: 8px;'>Puissance & Flexibilité</h3></div><div style='display: grid; grid-template-columns: repeat(2, 1fr); gap: 16px;'><div style='background: #282a36; border-radius: 6px; padding: 12px;'><div style='color: #9cdcfe; font-size: 12px; margin-bottom: 8px; font-weight: 500;'>Désemballage profond</div><div style='font-family: \"Fira Code\", Consolas, monospace; font-size: 11px; line-height: 1.5;'><span style='color: #569cd6;'>Promise⟨⟨⟨T⟩⟩⟩</span><div style='margin: 8px 0 8px 24px; opacity: 0.6;'>↓</div><span style='color: #9cdcfe;'>T</span></div></div><div style='background: #282a36; border-radius: 6px; padding: 12px;'><div style='color: #9cdcfe; font-size: 12px; margin-bottom: 8px; font-weight: 500;'>Unions de types</div><div style='font-family: \"Fira Code\", Consolas, monospace; font-size: 11px; line-height: 1.5;'><span style='color: #569cd6;'>A | Promise⟨B⟩</span><div style='margin: 8px 0 8px 24px; opacity: 0.6;'>↓</div><span style='color: #9cdcfe;'>A | B</span></div></div></div><div style='background: #282a36; border-radius: 6px; padding: 16px; margin-top: 16px;'><div style='text-align: center; color: #999999; font-size: 13px; font-style: italic;'>\"Awaited agit sur chaque membre d'une union indépendamment\"</div></div></div>"
          }
        },
        {
          "title": "Usage pratique avec ReturnType",
          "text": "La combinaison Awaited + ReturnType est essentielle pour extraire le type réel retourné par une fonction asynchrone, simplifiant le typage des données.",
          "code": "async function fetchUser(): Promise<{ id: number; name: string }> {\n  const response = await fetch('/api/user');\n  return response.json();\n}\n\n// Extraction du type de retour\ntype UserData = Awaited<ReturnType<typeof fetchUser>>;\n// type UserData = { id: number; name: string }\n\n// Utilisation directe du type\nfunction processUser(user: UserData) {\n  console.log(`Utilisateur ${user.name} (ID: ${user.id})`);\n}",
          "visualDemo": {
            "content": "<div style='background: linear-gradient(to bottom, #1e1e1e, #252526); border-radius: 8px; padding: 24px; font-family: -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, Oxygen, Ubuntu, Cantarell, sans-serif; color: #d4d4d4; box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);'><div style='text-align: center; margin-bottom: 24px;'><h3 style='font-size: 18px; font-weight: 500; color: #f5f5f5; margin-bottom: 8px;'>Pattern ReturnType + Awaited</h3></div><div style='background: #282a36; border-radius: 6px; padding: 16px; margin-bottom: 16px;'><div style='font-family: \"Fira Code\", Consolas, monospace; font-size: 14px; line-height: 1.5;'><span style='color: #9cdcfe;'>function</span> <span style='color: #dcdcaa;'>fetchData</span>() → <span style='color: #569cd6;'>Promise&lt;User&gt;</span></div></div><div style='background: #282a36; border-radius: 6px; padding: 16px; margin-bottom: 16px;'><div style='display: flex; justify-content: center; align-items: center; gap: 8px; margin-bottom: 12px;'><span style='background: #387d25; color: white; padding: 2px 8px; border-radius: 3px; font-size: 13px;'>ReturnType</span><span style='opacity: 0.6;'>+</span><span style='background: #1976d2; color: white; padding: 2px 8px; border-radius: 3px; font-size: 13px;'>Awaited</span></div><div style='text-align: center; font-family: \"Fira Code\", Consolas, monospace; font-size: 14px; color: #9cdcfe;'>User</div></div><div style='background: #387d25; border-radius: 6px; padding: 16px; color: #e6f1e6;'><div style='font-size: 13px; text-align: center;'>Type extrait prêt à l'emploi ✨</div></div></div>"
          }
        },
        {
          "title": "Mécanisme interne simplifié",
          "text": "Le fonctionnement d'Awaited<Type> est basé sur des tests de conditions TypeScript qui détectent récursivement les objets 'thenable' et extraient leurs valeurs.",
          "code": "// Version simplifiée du fonctionnement interne\ntype Awaited<T> =\n  T extends null | undefined ? T :\n  T extends object & { then(onfulfilled: infer F): any } ?\n    F extends ((value: infer V, ...args: any) => any) ?\n      Awaited<V> :\n      never :\n  T;",
          "visualDemo": {
            "content": "<div style='background: linear-gradient(to bottom, #1e1e1e, #252526); border-radius: 8px; padding: 24px; font-family: -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, Oxygen, Ubuntu, Cantarell, sans-serif; color: #d4d4d4; box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);'><div style='text-align: center; margin-bottom: 24px;'><h3 style='font-size: 18px; font-weight: 500; color: #f5f5f5; margin-bottom: 8px;'>Logique d'Awaited</h3></div><div style='background: #282a36; border-radius: 6px; padding: 16px; margin-bottom: 16px;'><div style='display: flex; flex-direction: column; gap: 12px;'><div style='display: flex; align-items: center; gap: 8px;'><div style='background: #569cd6; width: 8px; height: 8px; border-radius: 50%;'></div><span style='color: #9cdcfe; font-size: 14px;'>Est-ce null/undefined ?</span></div><div style='display: flex; align-items: center; gap: 8px;'><div style='background: #569cd6; width: 8px; height: 8px; border-radius: 50%;'></div><span style='color: #9cdcfe; font-size: 14px;'>A-t-il une méthode then() ?</span></div><div style='display: flex; align-items: center; gap: 8px;'><div style='background: #569cd6; width: 8px; height: 8px; border-radius: 50%;'></div><span style='color: #9cdcfe; font-size: 14px;'>Extraire la valeur résolue</span></div><div style='display: flex; align-items: center; gap: 8px;'><div style='background: #569cd6; width: 8px; height: 8px; border-radius: 50%;'></div><span style='color: #9cdcfe; font-size: 14px;'>Répéter jusqu'à obtenir T !</span></div></div></div><div style='background: #252a36; border: 1px dashed #569cd6; border-radius: 6px; padding: 16px; text-align: center;'><div style='font-size: 13px; color: #999999; font-style: italic;'>Récursion intelligente pour désemballer complètement les Promises</div></div></div>"
          }
        }
      ]
    },
    "exercises": [
      {
        "type": "qcm",
        "question": "Quel sera le résultat de type Awaited<Promise<Promise<number>>> ?",
        "options": [
          "Promise<Promise<number>>",
          "Promise<number>",
          "number",
          "unknown"
        ],
        "correctAnswer": 2,
        "explanation": "Awaited<Type> désemballe récursivement les Promises imbriquées, peu importe le niveau d'imbrication. Pour Awaited<Promise<Promise<number>>>, le résultat sera donc 'number'."
      },
      {
        "type": "vrai_faux",
        "question": "Awaited<string | Promise<number>> donnera comme résultat string | number.",
        "correctAnswer": true,
        "explanation": "Oui, c'est vrai. Awaited<Type> fonctionne sur les unions de types et applique le désemballage à chaque membre de l'union séparément. Pour 'string', il reste 'string' (car ce n'est pas une Promise), et pour Promise<number>, il devient 'number'."
      },
      {
        "type": "completion",
        "question": "Complétez le code pour obtenir directement le type de données retourné par la fonction fetchData sans l'enveloppe Promise :",
        "codeTemplate": "async function fetchData() {\n  const response = await fetch('/api/users');\n  return await response.json() as User[];\n}\n\ntype Result = [?]<ReturnType<typeof fetchData>>;",
        "correctAnswer": "Awaited",
        "explanation": "La fonction fetchData retourne Promise<User[]>. En utilisant ReturnType<typeof fetchData>, on obtient ce type Promise<User[]>. Pour extraire User[] de cette Promise, on utilise Awaited<>."
      },
      {
        "type": "debugging",
        "question": "Trouvez et corrigez l'erreur dans ce code TypeScript :",
        "buggyCode": "async function getData(): Promise<string> {\n  return 'data';\n}\n\n// Tentative d'utiliser le type retourné\ntype DataType = ReturnType<typeof getData>;\nconst processData = (data: DataType) => {\n  console.log(data.toUpperCase());\n};",
        "correctAnswer": "async function getData(): Promise<string> {\n  return 'data';\n}\n\n// Utilisez Awaited pour extraire le type de la Promise\ntype DataType = Awaited<ReturnType<typeof getData>>;\nconst processData = (data: DataType) => {\n  console.log(data.toUpperCase());\n};",
        "explanation": "L'erreur est que ReturnType<typeof getData> donne Promise<string>, mais processData essaie d'utiliser .toUpperCase() directement sur ce type. Or, .toUpperCase() est une méthode de string, pas de Promise<string>. En utilisant Awaited<ReturnType<typeof getData>>, on obtient le type string, ce qui permet d'appeler .toUpperCase()."
      }
    ],
    "related": ["Promise", "ReturnType", "Partial", "Required", "async-await", "generics"]
  }
}